import { app, BrowserWindow, ipcMain } from 'electron';
// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

import fs from 'fs';
import watch from 'node-watch';

let watcher: fs.FSWatcher | null = null;
let fileCurrentSize = 0;

const createWindow = () => {
    const mainWindow = new BrowserWindow({
        width: 800, height: 600,
        minWidth: 700, minHeight: 200,
        alwaysOnTop: true,
        autoHideMenuBar: true,
        frame: false,
        movable: true,
        webPreferences: {
            preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
        }
    });
    // and load the index.html of the app.
    mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);
}

app.on('window-all-closed', () => {
    watcher?.close();
    app.quit();
});

app.whenReady().then(() => {
    ipcMain.handle('read-settings', async () => {
        console.log('reading settings');
        const promise = new Promise<string | null>((resolve, reject) => {
            fs.readFile('setting.json', (err, data) => {
                if (err) {
                    console.error('read settings failed', err);
                    return resolve(null);
                }
                return resolve(data.toString());
            });
        });
        return await promise;
    });
    ipcMain.handle('open-file', async (event, filename) => {
        console.log('loading', filename);
        const promise = new Promise<string | null>((resolve, reject) => {
            fs.readFile(filename, (err, data) => {
                if (err) {
                    console.error('load failed', err, filename);
                    return resolve(null);
                }
                return resolve(data.toString());
            });
        });
        return await promise;
    });
    ipcMain.on('watch-file', (event, filename) => {
        watcher?.close();
        console.log('watching file', filename);
        fileCurrentSize = fs.statSync(filename).size;
        watcher = watch(filename, { recursive: false, delay: 200 }, (evt, name) => {
            console.log('watching file changed', evt, name);
            if (evt !== "update") {
                return;
            }
            const fd = fs.openSync(filename, 'r');
            const buffer = Buffer.alloc(fs.statSync(filename).size - fileCurrentSize);
            fs.readSync(fd, buffer, 0, buffer.length, fileCurrentSize);
            fs.closeSync(fd);
            fileCurrentSize = fs.statSync(filename).size;
            event.reply('watch-file-reply', buffer.toString());
        });
    });
    ipcMain.on('unwatch-file', () => {
        watcher?.close();
        watcher = null;
        fileCurrentSize = 0;
    });
    ipcMain.on('open-dev-tools', () => {
        BrowserWindow.getFocusedWindow()?.webContents.openDevTools({ mode: 'detach' });
    });
    ipcMain.on('window-minimize', () => {
        BrowserWindow.getFocusedWindow()?.minimize();
    });
    ipcMain.on('window-maximize', () => {
        const window = BrowserWindow.getFocusedWindow();
        if (window?.isMaximized()) {
            window.unmaximize();
        } else {
            window?.maximize();
        }
    });
    createWindow();
});
